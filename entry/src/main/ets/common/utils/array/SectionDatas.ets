export class SectionDatas<K, T extends Object> {

  private sectionOrder: K[] = [];          // åˆ†ç»„é¡ºåº
  private sectionMap: Map<K, T[]> = new Map(); // åˆ†ç»„ -> æ•°æ®åˆ—è¡¨

  // ç¼“å­˜ï¼ˆè‡ªåŠ¨å¤±æ•ˆï¼‰
  private cachedAllDatas: T[] | null = null;
  private cachedSectionStarts: number[] | null = null; // æ¯ä¸ªåˆ†ç»„å¼€å§‹çš„ indexï¼ˆæ–¹ä¾¿åš indexOfAllï¼‰

  // ========== å†…éƒ¨å·¥å…· ==========

  private invalidateCache(): void {
    this.cachedAllDatas = null;
    this.cachedSectionStarts = null;
  }

  private ensureSectionExists(section: K): void {
    if (!this.sectionMap.has(section)) {
      this.sectionMap.set(section, []);
      this.sectionOrder.push(section);
      this.invalidateCache();
    }
  }

  // ========== æ·»åŠ æ•°æ® ==========

  addSection(section: K): boolean {
    if (this.sectionMap.has(section)) return false;

    this.sectionMap.set(section, []);
    this.sectionOrder.push(section);
    this.invalidateCache();
    return true;
  }

  addSectionWithData(section: K, data: T): void {
    this.ensureSectionExists(section);
    this.sectionMap.get(section)!.push(data);
    this.invalidateCache();
  }

  addSectionWithDatas(section: K, datas: T[]): void {
    this.ensureSectionExists(section);
    this.sectionMap.get(section)!.push(...datas);
    this.invalidateCache();
  }

  // ========== æŸ¥è¯¢ ==========

  allSections(): K[] {
    return this.sectionOrder;
  }

  allDatasOfSection(section: K): T[] {
    return this.sectionMap.get(section) ?? [];
  }

  allDatasOfSectionIndex(index: number): T[] {
    return this.sectionMap.get(this.sectionOrder[index])!;
  }

  /**
   * â­ è¶…é«˜é€Ÿç‰ˆæœ¬ allDatas()
   * - å†…æœ‰ç¼“å­˜ â†’ æ¯æ¬¡è°ƒç”¨éƒ½æ˜¯ O(1)
   */
  allDatas(): T[] {
    if (this.cachedAllDatas != null) return this.cachedAllDatas;

    let total = 0;
    for (const section of this.sectionOrder) {
      total += this.sectionMap.get(section)!.length;
    }

    const result = new Array<T>(total);
    let offset = 0;

    for (const section of this.sectionOrder) {
      const arr = this.sectionMap.get(section)!;
      for (let i = 0; i < arr.length; i++) {
        result[offset++] = arr[i];
      }
    }

    this.cachedAllDatas = result;
    return result;
  }

  // ========== section ç´¢å¼• ==========

  indexOfSection(section: K): number | null {
    const i = this.sectionOrder.indexOf(section);
    return i === -1 ? null : i;
  }

  /**
   * è·å–æŸä¸ªåˆ†ç»„å†…æŸæ¡æ•°æ®çš„ç´¢å¼•ï¼ˆå¸¦ç¼“å­˜çš„é«˜æ•ˆç‰ˆæœ¬ï¼‰
   */
  indexOfData(data: T, section: K): number | null {
    const arr = this.sectionMap.get(section);
    if (!arr) return null;

    // ä½¿ç”¨ indexOfï¼ŒArkTS ä¼˜åŒ–è¿‡ï¼Œæ€§èƒ½æé«˜
    const idx = arr.indexOf(data);
    return idx === -1 ? null : idx;
  }

  sectionAtIndex(index: number): K | null {
    if (index < 0 || index >= this.sectionOrder.length) return null;
    return this.sectionOrder[index];
  }

  // ========== æ•°æ®ç´¢å¼• ==========

  /**
   * â­ è¶…é«˜é€Ÿ indexOfAllï¼ˆä½¿ç”¨ç¼“å­˜ï¼‰
   */
  indexOfAllFromIndex(rowIndex: number, sectionIndex: number): number {
    if (this.cachedSectionStarts == null) {
      this.cachedSectionStarts = [];

      let running = 0;
      for (let i = 0; i < this.sectionOrder.length; i++) {
        this.cachedSectionStarts[i] = running;
        running += this.allDatasOfSectionIndex(i).length;
      }
    }

    return this.cachedSectionStarts[sectionIndex] + rowIndex;
  }

  // ========== åˆ é™¤ ==========

  removeAll(): void {
    this.sectionOrder = [];
    this.sectionMap.clear();
    this.invalidateCache();
  }

  removeSectionAtIndex(sectionIndex: number): void {
    const section = this.sectionOrder[sectionIndex];
    this.sectionOrder.splice(sectionIndex, 1);
    this.sectionMap.delete(section);
    this.invalidateCache();
  }

  removeSection(section: K): void {
    const idx = this.indexOfSection(section);
    if (idx != null) this.removeSectionAtIndex(idx);
  }

  removeData(rowIndex: number, sectionIndex: number): void {
    const section = this.sectionOrder[sectionIndex];
    const arr = this.sectionMap.get(section)!;
    arr.splice(rowIndex, 1);
    this.invalidateCache();
  }


  // ========== æ•°æ®å®šä½ ==========

  sectionOfData(data: T): K | null {
    for (const section of this.sectionOrder) {
      const arr = this.sectionMap.get(section)!;
      if (arr.includes(data)) return section;
    }
    return null;
  }



  /**
   * ğŸ”’ ç§æœ‰ä½çº§å·¥å…·æ–¹æ³•ï¼šåœ¨æ•°ç»„ä¸­æœç´¢æ•°æ®çš„ç´¢å¼•
   * ï¼ˆæ—§ç‰ˆå…¼å®¹ï¼ŒæŸäº›å¤–éƒ¨é€»è¾‘å¯èƒ½ä¾èµ–å®ƒï¼‰
   */
  private indexOfDataInDatas(data: T, datas: T[]): number | null {
    const idx = datas.indexOf(data);
    return idx === -1 ? null : idx;
  }
}